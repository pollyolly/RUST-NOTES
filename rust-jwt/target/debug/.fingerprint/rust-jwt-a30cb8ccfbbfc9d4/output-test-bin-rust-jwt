{"message":"expected identifier, found `&`","code":null,"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":1925,"byte_end":1926,"line_start":73,"line_end":73,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                &jwt,","highlight_start":17,"highlight_end":18}],"label":"expected identifier","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/auth.rs","byte_start":1891,"byte_end":1907,"line_start":72,"line_end":72,"column_start":27,"column_end":43,"is_primary":false,"text":[{"text":"            let decoded = decode::<Claims>{","highlight_start":27,"highlight_end":43}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected identifier, found `&`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:73:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let decoded = decode::<Claims>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &jwt,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected identifier\u001b[0m\n\n"}
{"message":"expected identifier, found `&`","code":null,"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":1948,"byte_end":1949,"line_start":74,"line_end":74,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"                 &DecodingKey::from_secret(JWT_SECRET),","highlight_start":18,"highlight_end":19}],"label":"expected identifier","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/auth.rs","byte_start":1891,"byte_end":1907,"line_start":72,"line_end":72,"column_start":27,"column_end":43,"is_primary":false,"text":[{"text":"            let decoded = decode::<Claims>{","highlight_start":27,"highlight_end":43}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected identifier, found `&`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:74:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let decoded = decode::<Claims>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                &jwt,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                 &DecodingKey::from_secret(JWT_SECRET),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected identifier\u001b[0m\n\n"}
{"message":"expected identifier, found `&`","code":null,"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":2004,"byte_end":2005,"line_start":75,"line_end":75,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"                 &Validation::new(Algorithm::HS256),","highlight_start":18,"highlight_end":19}],"label":"expected identifier","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/auth.rs","byte_start":1891,"byte_end":1907,"line_start":72,"line_end":72,"column_start":27,"column_end":43,"is_primary":false,"text":[{"text":"            let decoded = decode::<Claims>{","highlight_start":27,"highlight_end":43}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected identifier, found `&`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:75:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let decoded = decode::<Claims>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                 &Validation::new(Algorithm::HS256),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected identifier\u001b[0m\n\n"}
{"message":"expected struct, variant or union type, found function `decode`","code":{"code":"E0574","explanation":"Something other than a struct, variant or union has been used when one was\nexpected.\n\nErroneous code example:\n\n```compile_fail,E0574\nmod mordor {}\n\nlet sauron = mordor { x: () }; // error!\n\nenum Jak {\n    Daxter { i: isize },\n}\n\nlet eco = Jak::Daxter { i: 1 };\nmatch eco {\n    Jak { i } => {} // error!\n}\n```\n\nIn all these errors, a type was expected. For example, in the first error,\nwe tried to instantiate the `mordor` module, which is impossible. If you want\nto instantiate a type inside a module, you can do it as follow:\n\n```\nmod mordor {\n    pub struct TheRing {\n        pub x: usize,\n    }\n}\n\nlet sauron = mordor::TheRing { x: 1 }; // ok!\n```\n\nIn the second error, we tried to bind the `Jak` enum directly, which is not\npossible: you can only bind one of its variants. To do so:\n\n```\nenum Jak {\n    Daxter { i: isize },\n}\n\nlet eco = Jak::Daxter { i: 1 };\nmatch eco {\n    Jak::Daxter { i } => {} // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":1891,"byte_end":1907,"line_start":72,"line_end":72,"column_start":27,"column_end":43,"is_primary":true,"text":[{"text":"            let decoded = decode::<Claims>{","highlight_start":27,"highlight_end":43}],"label":"not a struct, variant or union type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0574]\u001b[0m\u001b[0m\u001b[1m: expected struct, variant or union type, found function `decode`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:72:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let decoded = decode::<Claims>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a struct, variant or union type\u001b[0m\n\n"}
{"message":"unused import: `filters::ws::Message`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":220,"byte_end":240,"line_start":7,"line_end":7,"column_start":53,"column_end":73,"is_primary":true,"text":[{"text":"use warp::{reject, reply, Filter, Rejection, Reply, filters::ws::Message};","highlight_start":53,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":218,"byte_end":240,"line_start":7,"line_end":7,"column_start":51,"column_end":73,"is_primary":true,"text":[{"text":"use warp::{reject, reply, Filter, Rejection, Reply, filters::ws::Message};","highlight_start":51,"highlight_end":73}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `filters::ws::Message`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:53\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse warp::{reject, reply, Filter, Rejection, Reply, filters::ws::Message};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused imports: `DecodingKey`, `Validation`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/auth.rs","byte_start":153,"byte_end":164,"line_start":4,"line_end":4,"column_start":47,"column_end":58,"is_primary":true,"text":[{"text":"use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};","highlight_start":47,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/auth.rs","byte_start":187,"byte_end":197,"line_start":4,"line_end":4,"column_start":81,"column_end":91,"is_primary":true,"text":[{"text":"use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};","highlight_start":81,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/auth.rs","byte_start":151,"byte_end":164,"line_start":4,"line_end":4,"column_start":45,"column_end":58,"is_primary":true,"text":[{"text":"use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};","highlight_start":45,"highlight_end":58}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/auth.rs","byte_start":185,"byte_end":197,"line_start":4,"line_end":4,"column_start":79,"column_end":91,"is_primary":true,"text":[{"text":"use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};","highlight_start":79,"highlight_end":91}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `DecodingKey`, `Validation`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:4:47\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot check whether the hidden type of opaque type satisfies auto traits","code":null,"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":1177,"byte_end":1185,"line_start":50,"line_end":50,"column_start":6,"column_end":14,"is_primary":false,"text":[{"text":"    .and_then(authorize)","highlight_start":6,"highlight_end":14}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/auth.rs","byte_start":1186,"byte_end":1195,"line_start":50,"line_end":50,"column_start":15,"column_end":24,"is_primary":true,"text":[{"text":"    .and_then(authorize)","highlight_start":15,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"opaque type is declared here","code":null,"level":"note","spans":[{"file_name":"src/auth.rs","byte_start":1787,"byte_end":1804,"line_start":69,"line_end":69,"column_start":72,"column_end":89,"is_primary":true,"text":[{"text":"async fn authorize((role, headers): (Role, HeaderMap<HeaderValue>)) -> WebResult<String>{","highlight_start":72,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/auth.rs","byte_start":1787,"byte_end":1804,"line_start":69,"line_end":69,"column_start":72,"column_end":89,"is_primary":false,"text":[{"text":"async fn authorize((role, headers): (Role, HeaderMap<HeaderValue>)) -> WebResult<String>{","highlight_start":72,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `async` block or function","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"this item depends on auto traits of the hidden type, but may also be registering the hidden type. This is not supported right now. You can try moving the opaque type and the item that actually registers a hidden type into a new submodule","code":null,"level":"note","spans":[{"file_name":"src/auth.rs","byte_start":991,"byte_end":1000,"line_start":47,"line_end":47,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"pub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `and_then`","code":null,"level":"note","spans":[{"file_name":"/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/mod.rs","byte_start":7078,"byte_end":7086,"line_start":222,"line_end":222,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"    fn and_then<F>(self, fun: F) -> AndThen<Self, F>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/mod.rs","byte_start":7226,"byte_end":7230,"line_start":226,"line_end":226,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"        F::Output: TryFuture + Send,","highlight_start":32,"highlight_end":36}],"label":"required by this bound in `Filter::and_then`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot check whether the hidden type of opaque type satisfies auto traits\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:50:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    .and_then(authorize)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: opaque type is declared here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:69:72\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0masync fn authorize((role, headers): (Role, HeaderMap<HeaderValue>)) -> WebResult<String>{\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: this item depends on auto traits of the hidden type, but may also be registering the hidden type. This is not supported right now. You can try moving the opaque type and the item that actually registers a hidden type into a new submodule\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:47:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `and_then`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/mod.rs:226:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn and_then<F>(self, fun: F) -> AndThen<Self, F>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m226\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        F::Output: TryFuture + Send,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Filter::and_then`\u001b[0m\n\n"}
{"message":"cannot check whether the hidden type of opaque type satisfies auto traits","code":null,"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":1016,"byte_end":1075,"line_start":47,"line_end":47,"column_start":33,"column_end":92,"is_primary":true,"text":[{"text":"pub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {","highlight_start":33,"highlight_end":92}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/auth.rs","byte_start":1016,"byte_end":1075,"line_start":47,"line_end":47,"column_start":33,"column_end":92,"is_primary":false,"text":[{"text":"pub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {","highlight_start":33,"highlight_end":92}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"opaque type is declared here","code":null,"level":"note","spans":[{"file_name":"src/auth.rs","byte_start":1787,"byte_end":1804,"line_start":69,"line_end":69,"column_start":72,"column_end":89,"is_primary":true,"text":[{"text":"async fn authorize((role, headers): (Role, HeaderMap<HeaderValue>)) -> WebResult<String>{","highlight_start":72,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/auth.rs","byte_start":1787,"byte_end":1804,"line_start":69,"line_end":69,"column_start":72,"column_end":89,"is_primary":false,"text":[{"text":"async fn authorize((role, headers): (Role, HeaderMap<HeaderValue>)) -> WebResult<String>{","highlight_start":72,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `async` block or function","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"this item depends on auto traits of the hidden type, but may also be registering the hidden type. This is not supported right now. You can try moving the opaque type and the item that actually registers a hidden type into a new submodule","code":null,"level":"note","spans":[{"file_name":"src/auth.rs","byte_start":991,"byte_end":1000,"line_start":47,"line_end":47,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"pub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required for `AndThen<Map<impl Filter + FilterBase<Extract = (HeaderMap,), Error = Infallible> + Copy, ...>, ...>` to implement `warp::filter::FilterBase`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full type name has been written to '/Users/roco/Desktop/GitHub/RUST-NOTES/rust-jwt/target/debug/deps/rust_jwt-a30cb8ccfbbfc9d4.long-type-17459691263257754726.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot check whether the hidden type of opaque type satisfies auto traits\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:47:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: opaque type is declared here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:69:72\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0masync fn authorize((role, headers): (Role, HeaderMap<HeaderValue>)) -> WebResult<String>{\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: this item depends on auto traits of the hidden type, but may also be registering the hidden type. This is not supported right now. You can try moving the opaque type and the item that actually registers a hidden type into a new submodule\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:47:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn with_auth(role: Role) -> impl Filter<Extract = (String,), Error = Rejection> + Clone {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `AndThen<Map<impl Filter + FilterBase<Extract = (HeaderMap,), Error = Infallible> + Copy, ...>, ...>` to implement `warp::filter::FilterBase`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full type name has been written to '/Users/roco/Desktop/GitHub/RUST-NOTES/rust-jwt/target/debug/deps/rust_jwt-a30cb8ccfbbfc9d4.long-type-17459691263257754726.txt'\u001b[0m\n\n"}
{"message":"unused variable: `message`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/error.rs","byte_start":777,"byte_end":784,"line_start":30,"line_end":30,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"    let (code, message) = if err.is_not_found(){","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/error.rs","byte_start":777,"byte_end":784,"line_start":30,"line_end":30,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"    let (code, message) = if err.is_not_found(){","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":"_message","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `message`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/error.rs:30:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let (code, message) = if err.is_not_found(){\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_message`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"message":"the method `and_then` exists for struct `And<And<And<impl Filter + FilterBase<Extract = (), Error = Infallible> + Copy, Exact<Opaque<...>>>, ...>, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1087,"byte_end":1152,"line_start":46,"line_end":48,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"    let user_route = warp::path!(\"user\")","highlight_start":22,"highlight_end":41},{"text":"        .and(with_auth(Role::User))","highlight_start":1,"highlight_end":36},{"text":"        .and_then(user_handler);","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1152,"byte_end":1160,"line_start":48,"line_end":48,"column_start":10,"column_end":18,"is_primary":true,"text":[{"text":"        .and_then(user_handler);","highlight_start":10,"highlight_end":18}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/and.rs","byte_start":262,"byte_end":282,"line_start":12,"line_end":12,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct And<T, U> {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `_: FilterBase`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/and.rs","byte_start":262,"byte_end":282,"line_start":12,"line_end":12,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct And<T, U> {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `_: Filter`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full type name has been written to '/Users/roco/Desktop/GitHub/RUST-NOTES/rust-jwt/target/debug/deps/rust_jwt-a30cb8ccfbbfc9d4.long-type-14646117007403660059.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following trait bounds were not satisfied:\n`warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\nwhich is required by `warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\n`&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\nwhich is required by `&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\n`&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\nwhich is required by `&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `and_then` exists for struct `And<And<And<impl Filter + FilterBase<Extract = (), Error = Infallible> + Copy, Exact<Opaque<...>>>, ...>, ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:48:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let user_route = warp::path!(\"user\")\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .and(with_auth(Role::User))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .and_then(user_handler);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/and.rs:12:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct And<T, U> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: FilterBase`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: Filter`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full type name has been written to '/Users/roco/Desktop/GitHub/RUST-NOTES/rust-jwt/target/debug/deps/rust_jwt-a30cb8ccfbbfc9d4.long-type-14646117007403660059.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\u001b[0m\n\u001b[0m           which is required by `warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\u001b[0m\n\u001b[0m           `&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\u001b[0m\n\u001b[0m           which is required by `&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\u001b[0m\n\u001b[0m           `&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\u001b[0m\n\u001b[0m           which is required by `&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\u001b[0m\n\n"}
{"message":"the method `and_then` exists for struct `And<And<And<impl Filter + FilterBase<Extract = (), Error = Infallible> + Copy, Exact<Opaque<...>>>, ...>, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1198,"byte_end":1265,"line_start":49,"line_end":51,"column_start":23,"column_end":10,"is_primary":false,"text":[{"text":"    let admin_route = warp::path!(\"admin\")","highlight_start":23,"highlight_end":43},{"text":"        .and(with_auth(Role::Admin))","highlight_start":1,"highlight_end":37},{"text":"        .and_then(admin_handler);","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1265,"byte_end":1273,"line_start":51,"line_end":51,"column_start":10,"column_end":18,"is_primary":true,"text":[{"text":"        .and_then(admin_handler);","highlight_start":10,"highlight_end":18}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/and.rs","byte_start":262,"byte_end":282,"line_start":12,"line_end":12,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct And<T, U> {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `_: FilterBase`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/and.rs","byte_start":262,"byte_end":282,"line_start":12,"line_end":12,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct And<T, U> {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `_: Filter`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full type name has been written to '/Users/roco/Desktop/GitHub/RUST-NOTES/rust-jwt/target/debug/deps/rust_jwt-a30cb8ccfbbfc9d4.long-type-13001443673192225008.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following trait bounds were not satisfied:\n`warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\nwhich is required by `warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\n`&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\nwhich is required by `&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\n`&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\nwhich is required by `&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `and_then` exists for struct `And<And<And<impl Filter + FilterBase<Extract = (), Error = Infallible> + Copy, Exact<Opaque<...>>>, ...>, ...>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:51:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let admin_route = warp::path!(\"admin\")\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m_______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .and(with_auth(Role::Admin))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .and_then(admin_handler);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/roco/.cargo/registry/src/index.crates.io-6f17d22bba15001f/warp-0.2.5/src/filter/and.rs:12:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct And<T, U> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: FilterBase`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `_: Filter`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full type name has been written to '/Users/roco/Desktop/GitHub/RUST-NOTES/rust-jwt/target/debug/deps/rust_jwt-a30cb8ccfbbfc9d4.long-type-13001443673192225008.txt'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\u001b[0m\n\u001b[0m           which is required by `warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\u001b[0m\n\u001b[0m           `&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\u001b[0m\n\u001b[0m           which is required by `&warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\u001b[0m\n\u001b[0m           `&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::filter::FilterBase`\u001b[0m\n\u001b[0m           which is required by `&mut warp::filter::and::And<warp::filter::and::And<warp::filter::and::And<impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Infallible> + std::marker::Copy, Exact<warp::path::internal::Opaque<main::{closure#0}::__StaticPath>>>, impl warp::Filter + warp::filter::FilterBase<Extract = (), Error = Rejection> + std::marker::Copy>, impl warp::Filter + warp::filter::FilterBase<Extract = (std::string::String,), Error = Rejection> + Clone>: warp::Filter`\u001b[0m\n\n"}
{"message":"aborting due to 8 previous errors; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 8 previous errors; 3 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0574, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0574, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0574`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0574`.\u001b[0m\n"}
